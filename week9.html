<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>week9.md</title><link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --code-block-bg-color: inherit; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { background: rgb(181, 214, 252); text-shadow: none; }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; contain: layout paint; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; }
#write li > table:first-child { margin-top: -20px; }
img { max-width: 100%; vertical-align: middle; }
input, button, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
::before, ::after, * { box-sizing: border-box; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.typora-export p { white-space: normal; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: var(--code-block-bg-color); position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.footnotes { opacity: 0.8; font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: transparent; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li p, li .mathjax-block { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; }
@media print {
  html, body { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0mm; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
.mathjax-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: none; box-shadow: none; }
.task-list { list-style-type: none; }
.task-list-item { position: relative; padding-left: 1em; }
.task-list-item input { position: absolute; top: 0px; left: 0px; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc::after, .md-toc-content::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: monospace; }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; background: transparent !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border-width: 0px 0px 1px; border-style: none none solid; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(204, 204, 204); margin: 0px; padding: 0px; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.task-list { padding-left: 0px; }
.task-list-item { padding-left: 32px; }
.task-list-item input { top: 3px; left: 8px; }
@media screen and (min-width: 914px) {
}
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
#md-notification::before { top: 10px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }






</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h1><a name='header-n552' class='md-header-anchor '></a>第9周</h1><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n552"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n552">第9周</a></span><span class="md-toc-item md-toc-h2" data-ref="n557"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n557">十五、异常检测(Anomaly Detection)</a></span><span class="md-toc-item md-toc-h3" data-ref="n558"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n558">15.1 问题的动机</a></span><span class="md-toc-item md-toc-h3" data-ref="n600"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n600">15.2 高斯分布</a></span><span class="md-toc-item md-toc-h3" data-ref="n619"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n619">15.3 算法</a></span><span class="md-toc-item md-toc-h3" data-ref="n652"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n652">15.4 开发和评价一个异常检测系统</a></span><span class="md-toc-item md-toc-h3" data-ref="n680"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n680">15.5 异常检测与监督学习对比</a></span><span class="md-toc-item md-toc-h3" data-ref="n705"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n705">15.6 选择特征</a></span><span class="md-toc-item md-toc-h3" data-ref="n728"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n728">15.7 多元高斯分布（可选）</a></span><span class="md-toc-item md-toc-h3" data-ref="n803"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n803">15.8 使用多元高斯分布进行异常检测（可选）</a></span><span class="md-toc-item md-toc-h2" data-ref="n856"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n856">十六、推荐系统(Recommender Systems)</a></span><span class="md-toc-item md-toc-h3" data-ref="n857"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n857">16.1 问题形式化</a></span><span class="md-toc-item md-toc-h3" data-ref="n891"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n891">16.2 基于内容的推荐系统</a></span><span class="md-toc-item md-toc-h3" data-ref="n931"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n931">16.3 协同过滤</a></span><span class="md-toc-item md-toc-h3" data-ref="n966"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n966">16.4 协同过滤算法</a></span><span class="md-toc-item md-toc-h3" data-ref="n1009"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n1009">16.5 向量化：低秩矩阵分解</a></span><span class="md-toc-item md-toc-h3" data-ref="n1084"><a class="md-toc-inner" style="cursor: pointer;" href="#header-n1084">16.6 推行工作上的细节：均值归一化</a></span></p></div><h2><a name='header-n557' class='md-header-anchor '></a>十五、异常检测(Anomaly Detection)</h2><h3><a name='header-n558' class='md-header-anchor '></a>15.1 问题的动机</h3><p>参考文档: 15 - 1 - Problem Motivation (8 min).mkv</p><p>在接下来的一系列视频中，我将向大家介绍异常检测(Anomaly detection)问题。这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p><p>什么是异常检测呢？为了解释这个概念，让我举一个例子吧：</p><p>假想你是一个飞机引擎制造商，当你生产的飞机引擎从生产线上流出时，你需要进行QA
(质量控制测试)，而作为这个测试的一部分，你测量了飞机引擎的一些特征变量，比如引擎运转时产生的热量，或者引擎的振动等等。</p><p><img src='media/93d6dfe7e5cb8a46923c178171889747.png' alt='' /></p><p>这样一来，你就有了一个数据集，从x(1)到x(m)，如果你生产了m个引擎的话，你将这些数据绘制成图表，看起来就是这个样子：</p><p><img src='media/fe4472adbf6ddd9d9b51d698cc750b68.png' alt='' /></p><p>这里的每个点、每个叉，都是你的无标签数据。这样，异常检测问题可以定义如下：我们假设后来有一天，你有一个新的飞机引擎从生产线上流出，而你的新飞机引擎有特征变量xtest。所谓的异常检测问题就是：我们希望知道这个新的飞机引擎是否有某种异常，或者说，我们希望判断这个引擎是否需要进一步测试。因为，如果它看起来像一个正常的引擎，那么我们可以直接将它运送到客户那里，而不需要进一步的测试。</p><p>给定数据集 x(1),x(2),..,x(m)，我们假使数据集是正常的，我们希望知道新的数据
xtest是不是异常的，即这个测试数据不属于该组数据的几率如何。我们所构建的模型应该能根据该测试数据的位置告诉我们其属于一组数据的可能性p(x)。</p><p><img src='media/65afdea865d50cba12d4f7674d599de5.png' alt='' /></p><p>上图中，在蓝色圈内的数据属于该组数据的可能性较高，而越是偏远的数据，其属于该组数据的可能性就越低。</p><p>这种方法称为密度估计，表达如下：</p><p><img src='media/e5d3e8bfd41a9e0a2be62ca242513e50.png' alt='' /></p><p>欺诈检测：</p><p>X(i) = 用户的第i个活动特征</p><p>模型p(x) =我们其属于一组数据的可能性</p><p>通过p(x)&lt;ε检测非正常用户。</p><p>异常检测主要用来识别欺骗。例如在线采集而来的有关用户的数据，一个特征向量中可能会包含如：用户多久登录一次，访问过的页面，在论坛发布的帖子数量，甚至是打字速度等。尝试根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户。</p><p>再一个例子是检测一个数据中心，特征可能包含：内存使用情况，被访问的磁盘数量，CPU
的负载，网络的通信量等。根据这些特征可以构建一个模型，用来判断某些计算机是不是有可能出错了。</p><h3><a name='header-n600' class='md-header-anchor '></a>15.2 高斯分布</h3><p>参考视频: 15 - 2 - Gaussian Distribution (10 min).mkv</p><p>在这个视频中，我将介绍高斯分布，也称为正态分布。回顾高斯分布的基本知识。</p><p>通常如果我们认为变量 x 符合高斯分布 x~N(μ,σ2)则其概率密度函数为：</p><p>我们可以利用已有的数据来预测总体中的μ和σ2 的计算方法如下：</p><p><img src='media/ad03b539f93a8440345d9ddf3af3b3ed.png' alt='' /></p><p><img src='media/36ddaa10b14ac1a4835547ed26b8bf7b.png' alt='' /></p><p>高斯分布样例：</p><p><img src='media/fcb35433507a56631dde2b4e543743ee.png' alt='' /></p><p>注：机器学习中对于方差我们通常只除以m而非统计学中的（m-1）。这里顺便提一下，在实际使用中，到底是选择使用1/m还是1/(m-1)其实区别很小，只要你有一个还算大的训练集，在机器学习领域大部分人更习惯使用1/m这个版本的公式。这两个版本的公式在理论特性和数学特性上稍有不同，但是在实际使用中，他们的区别甚小，几乎可以忽略不计。</p><h3><a name='header-n619' class='md-header-anchor '></a>15.3 算法</h3><p>参考视频: 15 - 3 - Algorithm (12 min).mkv</p><p>在本节视频中，我将应用高斯分布开发异常检测算法。</p><p>异常检测算法：</p><p>对于给定的数据集 x(1),x(2),...,x(m) ，我们要针对每一个特征计算μ和σ2 的估计值。</p><p><img src='media/1c69e8475fb75d271156c4a69af9d963.png' alt='' /></p><p>一旦我们获得了平均值和方差的估计值，给定新的一个训练实例，根据模型计算 p(x)：</p><p><img src='media/92dd64f6100a8ce490e0a3e67b4a506d.jpg' alt='' /></p><p>当p(x)&lt;ε时，为异常。</p><p>下图是一个由两个特征的训练集，以及特征的分布情况：</p><p><img src='media/ba47767a11ba39a23898b9f1a5a57cc5.png' alt='' /></p><p>下面的三维图表表示的是密度估计函数，z 轴为根据两个特征的值所估计p(x)值：</p><p><img src='media/82b90f56570c05966da116c3afe6fc91.jpg' alt='' /></p><p>我们选择一个ε，将 p(x)=ε作为我们的判定边界，当
p(x)&gt;ε时预测数据为正常数据，否则则为异常。</p><p>在这段视频中，我们介绍了如何拟合 p(x)，也就是 x
的概率值，以开发出一种异常检测算法。同时，在这节课中，我们也给出了通过给出的数据集拟合参数，进行参数估计，得到参数μ和σ，然后检测新的样本，确定新样本是否是异常。</p><p>在接下来的课程中，我们将深入研究这一算法，同时更深入地介绍，怎样让算法工作地更加有效。</p><h3><a name='header-n652' class='md-header-anchor '></a>15.4 开发和评价一个异常检测系统</h3><p>参考视频: 15 - 4 - Developing and Evaluating an Anomaly Detection System (13
min). mkv</p><p>异常检测算法是一个非监督学习算法，意味着我们无法根据结果变量 y
的值来告诉我们数据是否真的是异常的。我们需要另一种方法来帮助检验算法是否有效。当我们开发一个异常检测系统时，我们从带标记（异常或正常）的数据着手，我们从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成交叉检验集和测试集。</p><p>例如：我们有10000台正常引擎的数据，有20台异常引擎的数据。 我们这样分配数据：</p><p>6000台正常引擎的数据作为训练集</p><p>2000台正常引擎和10台异常引擎的数据作为交叉检验集</p><p>2000台正常引擎和10台异常引擎的数据作为测试集</p><p>具体的评价方法如下：</p><ol start='' ><li>根据测试集数据，我们估计特征的平均值和方差并构建p(x)函数</li><li>对交叉检验集，我们尝试使用不同的ε值作为阀值，并预测数据是否异常，根据F1
值或者查准率与查全率的比例来选择ε</li><li>选出ε后，针对测试集进行预测，计算异常检验系统的F1值，或者查准率与查全率之比</li></ol><h3><a name='header-n680' class='md-header-anchor '></a>15.5 异常检测与监督学习对比</h3><p>参考视频: 15 - 5 - Anomaly Detection vs. Supervised Learning (8 min).mkv</p><p>之前我们构建的异常检测系统也使用了带标记的数据，与监督学习有些相似，下面的对比有助于选择采用监督学习还是异常检测：</p><p>两者比较：</p><table><thead><tr><th>异常检测</th><th>监督学习</th></tr></thead><tbody><tr><td>非常少量的正向类（异常数据 y=1）, 大量的负向类（y=0）</td><td>同时有大量的正向类和负向类</td></tr><tr><td>许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。</td><td>有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。</td></tr><tr><td>未来遇到的异常可能与已掌握的异常、非常的不同。</td><td></td></tr><tr><td>例如： 1. 欺诈行为检测 2. 生产（例如飞机引擎） 3. 检测数据中心的计算机运行状况</td><td>例如： 1. 邮件过滤器 2. 天气预报 3. 肿瘤分类</td></tr></tbody></table><p>希望这节课能让你明白一个学习问题的什么样的特征，能让你把这个问题当做是一个异常检测，或者是一个监督学习的问题。另外，对于很多技术公司可能会遇到的一些问题，通常来说，正样本的数量很少，甚至有时候是0，也就是说，出现了太多没见过的不同的异常类型，那么对于这些问题，通常应该使用的算法就是异常检测算法。</p><h3><a name='header-n705' class='md-header-anchor '></a>15.6 选择特征</h3><p>参考视频: 15 - 6 - Choosing What Features to Use (12 min).mkv</p><p>对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征：</p><p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布，例如使用对数函数：x
= log(x+c)，其中 c 为非负常数； 或者 x=xc，c 为 0-1 之间的一个分数，等方法。</p><p><img src='media/0990d6b7a5ab3c0036f42083fe2718c6.jpg' alt='' /></p><p>误差分析：</p><p>一个常见的问题是一些异常的数据可能也会有较高的p(x)值，因而被算法认为是正常的。这种情况下误差分析能够帮助我们，我们可以分析那些被算法错误预测为正常的数据，观察能否找出一些问题。我们可能能从问题中发现我们需要增加一些新的特征，增加这些新特征后获得的新算法能够帮助我们更好地进行异常检测。</p><p>异常检测误差分析：</p><p><img src='media/f406bc738e5e032be79e52b6facfa48e.png' alt='' /></p><p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小），例如，在检测数据中心的计算机状况的例子中，我们可以用CPU
负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p><p>在这段视频中，我们介绍了如何选择特征，以及对特征进行一些小小的转换，让数据更像正态分布，然后再把数据输入异常检测算法。同时也介绍了建立特征时，进行的误差分析方法，来捕捉各种异常的可能。希望你通过这些方法，能够了解如何选择好的特征变量，从而帮助你的异常检测算法，捕捉到各种不同的异常情况。</p><h3><a name='header-n728' class='md-header-anchor '></a>15.7 多元高斯分布（可选）</h3><p>参考视频: 15 - 7 - Multivariate Gaussian Distribution (Optional) (14 min).mkv</p><p>假使我们有两个相关的特征，而且这两个特征的值域范围比较宽，这种情况下，一般的高斯分布模型可能不能很好地识别异常数据。其原因在于，一般的高斯分布模型尝试的是去同时抓住两个特征的偏差，因此创造出一个比较大的判定边界。</p><p>下图中是两个相关特征，洋红色的线（根据ε的不同其范围可大可小）是一般的高斯分布模型获得的判定边界，很明显绿色的X所代表的数据点很可能是异常值，但是其p(x)值却仍然在正常范围内。多元高斯分布将创建像图中蓝色曲线所示的判定边界。</p><p><img src='media/598db991a7c930c9021cec5f6ab9beb9.png' alt='' /></p><p>在一般的高斯分布模型中，我们计算p(x)的方法是：
通过分别计算每个特征对应的几率然后将其累乘起来，在多元高斯分布模型中，我们将构建特征的协方差矩阵，用所有的特征一起来计算p(x)。</p><p>我们首先计算所有特征的平均值，然后再计算协方差矩阵：</p><p><img src='media/92dd64f6100a8ce490e0a3e67b4a506d.jpg' alt='' /></p><p><img src='media/40c79900e56c4960750428453bc3fbca.png' alt='' /></p><p><img src='media/36ddaa10b14ac1a4835547ed26b8bf7b.png' alt='' /></p><p>注:其中μ是一个向量，其每一个单元都是原特征矩阵中一行数据的均值。最后我们计算多元高斯分布的p(x):</p><p><img src='media/a4de9afd38a3c3d57de546bd5b5669b3.png' alt='' /></p><p>其中：</p><p>|Σ|是定矩阵，在 Octave 中用 det(sigma)计算</p><p>Σ1 是逆矩阵，下面我们来看看协方差矩阵是如何影响模型的：</p><p><img src='media/29df906704d254f18e92a63173dd51e7.jpg' alt='' /></p><p>上图是5个不同的模型，从左往右依次分析：</p><ol start='' ><li>是一个一般的高斯分布模型</li><li>通过协方差矩阵，令特征1拥有较小的偏差，同时保持特征2的偏差</li><li>通过协方差矩阵，令特征2拥有较大的偏差，同时保持特征1的偏差</li><li>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的正相关性</li><li>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的负相关性</li></ol><p>多元高斯分布模型与原高斯分布模型的关系：</p><p>可以证明的是，原本的高斯分布模型是多元高斯分布模型的一个子集，即像上图中的第
1、2、3，3
个例子所示，如果协方差矩阵只在对角线的单位上有非零的值时，即为原本的高斯分布模型了。</p><p>原高斯分布模型和多元高斯分布模型的比较：</p><table><thead><tr><th>原高斯分布模型</th><th>多元高斯分布模型</th></tr></thead><tbody><tr><td>不能捕捉特征之间的相关性 但可以通过将特征进行组合的方法来解决</td><td>自动捕捉特征之间的相关性</td></tr><tr><td>计算代价低，能适应大规模的特征</td><td>计算代价较高 训练集较小时也同样适用</td></tr><tr><td></td><td>必须要有 m&gt;n，不然的话协方差矩阵 不可逆的，通常需要 m&gt;10n 另外特征冗余也会导致协方差矩阵不可逆</td></tr></tbody></table><p>原高斯分布模型被广泛使用着，如果特征之间在某种程度上存在相互关联的情况，我们可以通过构造新新特征的方法来捕捉这些相关性。</p><p>如果训练集不是太大，并且没有太多的特征，我们可以使用多元高斯分布模型。</p><h3><a name='header-n803' class='md-header-anchor '></a>15.8 使用多元高斯分布进行异常检测（可选）</h3><p>参考视频: 15 - 8 - Anomaly Detection using the Multivariate Gaussian
Distribution (Optional) (14 min).mkv</p><p>在我们谈到的最后一个视频，关于多元高斯分布，看到的一些建立的各种分布模型，当你改变参数，μ和Σ。在这段视频中，让我们用这些想法，并应用它们制定一个不同的异常检测算法。</p><p>要回顾一下多元高斯分布和多元正态分布：</p><p><img src='media/3dbee365617e9264831400e4de247adc.png' alt='' /></p><p>分布有两个参数，μ和Σ。其中μ这一个n维向量和Σ的协方差矩阵，是一种n乘n的矩阵。而这里的公式X的概率，如按μ和参数化Σ，和你的变量μ和Σ，你可以得到一个范围的不同分布一样，你知道的，这些都是三个样本，那些我们在以前的视频看过了。</p><p>因此，让我们谈谈参数拟合或参数估计问题：</p><p>我有一组样本</p><p><img src='media/1aa882140763ed77f2bd75e75637cc7e.png' alt='' /></p><p>是一个n维向量，我想我的样本来自一个多元高斯分布。我如何尝试估计我的参数μ和Σ以及标准公式？</p><p>估计他们是你设置μ是你的训练样本的平均值。</p><p><img src='media/c2a8dbcb9b3b8f77f1668daf6e709714.png' alt='' /></p><p>并设置Σ：</p><p><img src='media/c2a8dbcb9b3b8f77f1668daf6e709714.png' alt='' /></p><p>这其实只是当我们使用PCA算法时候，有Σ时写出来。所以你只需插入上述两个公式，这会给你你估计的参数μ和你估计的参数Σ。所以，这里给出的数据集是你如何估计μ和Σ。让我们以这种方法而只需将其插入到异常检测算法。那么，我们如何把所有这一切共同开发一个异常检测算法？</p><p><img src='media/d1a228f2bec262f2206379ed844c7f4a.png' alt='' /></p><p>首先，我们把我们的训练集，和我们的拟合模型，我们计算P(x)，要知道，设定μ和描述的一样Σ。</p><p><img src='media/015cee3a224dde6da0181215cf91a23d.png' alt='' /></p><p>如图，该分布在中央最多，越到外面的圈的范围越小。</p><p>并在该点是出路这里的概率非常低。</p><p>原始模型与多元高斯模型的关系如图：</p><p>其中：协方差矩阵Σ为：</p><p><img src='media/7104dd2548f1251e4c423e059d1d2594.png' alt='' /></p><p><img src='media/7104dd2548f1251e4c423e059d1d2594.png' alt='' /></p><p>原始模型和多元高斯分布比较如图：</p><p><img src='media/f4585239738f2b5149608879fa166889.png' alt='' /></p><h2><a name='header-n856' class='md-header-anchor '></a>十六、推荐系统(Recommender Systems)</h2><h3><a name='header-n857' class='md-header-anchor '></a>16.1 问题形式化</h3><p>参考视频: 16 - 1 - Problem Formulation (8 min).mkv</p><p>在接下来的视频中，我想讲一下推荐系统。我想讲推荐系统有两个原因：</p><p>第一、仅仅因为它是机器学习中的一个重要的应用。在过去几年，我偶尔访问硅谷不同的技术公司，我常和工作在这儿致力于机器学习应用的人们聊天，我常问他们，最重要的机器学习的应用是什么，或者，你最想改进的机器学习应用有哪些。我最常听到的答案是推荐系统。现在，在硅谷有很多团体试图建立很好的推荐系统。因此，如果你考虑网站像亚马逊，或网飞公司或易趣，或iTunes
Genius，有很多的网站或系统试图推荐新产品给用户。如，亚马逊推荐新书给你，网飞公司试图推荐新电影给你，等等。这些推荐系统，根据浏览你过去买过什么书，或过去评价过什么电影来判断。这些系统会带来很大一部分收入，比如为亚马逊和像网飞这样的公司。因此，对推荐系统性能的改善，将对这些企业的有实质性和直接的影响。</p><p>推荐系统是个有趣的问题，在学术机器学习中因此，我们可以去参加一个学术机器学习会议，推荐系统问题实际上受到很少的关注，或者，至少在学术界它占了很小的份额。但是，如果你看正在发生的事情，许多有能力构建这些系统的科技企业，他们似乎在很多企业中占据很高的优先级。这是我为什么在这节课讨论它的原因之一。</p><p>我想讨论推荐系统地第二个原因是：这个班视频的最后几集我想讨论机器学习中的一些大思想，并和大家分享。这节课我们也看到了，对机器学习来说，特征是很重要的，你所选择的特征，将对你学习算法的性能有很大的影响。因此，在机器学习中有一种大思想，它针对一些问题，可能并不是所有的问题，而是一些问题，有算法可以为你自动学习一套好的特征。因此，不要试图手动设计，而手写代码这是目前为止我们常干的。有一些设置，你可以有一个算法，仅仅学习其使用的特征，推荐系统就是类型设置的一个例子。还有很多其它的，但是通过推荐系统，我们将领略一小部分特征学习的思想，至少，你将能够了解到这方面的一个例子，我认为，机器学习中的大思想也是这样。因此，让我们开始讨论推荐系统问题形式化。</p><p>我们从一个例子开始定义推荐系统的问题。</p><p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p><p><img src='media/c2822f2c28b343d7e6ade5bd40f3a1fc.png' alt='' /></p><p>前三部电影是爱情片，后两部则是动作片，我们可以看出Alice
和Bob似乎更倾向与爱情片， 而 Carol 和 Dave
似乎更倾向与动作片。并且没有一个用户给所有的电影都打过分。我们希望构建一个算法来预测他们每个人可能会给他们没看过的电影打多少分，并以此作为推荐的依据。</p><p>下面引入一些标记：</p><p>nu 代表用户的数量</p><p>nm 代表电影的数量</p><p>r(i,j)如果用户j给电影i评过分则 r(i,j)=1</p><p>y(i,j)代表用户j给电影i的评分</p><p>mj代表用户j评过分的电影的总数</p><h3><a name='header-n891' class='md-header-anchor '></a>16.2 基于内容的推荐系统</h3><p>参考视频: 16 - 2 - Content Based Recommendations (15 min).mkv</p><p>在一个基于内容的推荐系统算法中，我们假设对于我们希望推荐的东西有一些数据，这些数据是有关这些东西的特征。</p><p>在我们的例子中，我们可以假设每部电影都有两个特征，如x1代表电影的浪漫程度，x2
代表电影的动作程度。</p><p><img src='media/747c1fd6bff694c6034da1911aa3314b.png' alt='' /></p><p>则每部电影都有一个特征向量，如x(1)是第一部电影的特征向量为[0.9 0]。</p><p>下面我们要基于这些特征来构建一个推荐系统算法。
假设我们采用线性回归模型，我们可以针对每一个用户都训练一个线性回归模型，如θ(1)是第一个用户的模型的参数。
于是，我们有：</p><p>θ(j)用户 j 的参数向量</p><p>x(i)电影 i 的特征向量</p><p>对于用户 j 和电影 i，我们预测评分为：(θ(j))Tx(i)</p><p>代价函数</p><p>针对用户j，该线性回归模型的代价为预测误差的平方和，加上正则化项：</p><p><img src='media/81dbcb183b58fc92d0c2f12011b1a1e6.png' alt='' /></p><p>其中 i:r(i,j)表示我们只计算那些用户 j
评过分的电影。在一般的线性回归模型中，误差项和正则项应该都是乘以
1/2m，在这里我们将m去掉。并且我们不对方差项θ0 进行正则化处理。</p><p>上面的代价函数只是针对一个用户的，为了学习所有用户，我们将所有用户的代价函数求和：</p><p><img src='media/97ce0b4bd2c8d83d746366ea6019833d.png' alt='' /></p><p>如果我们要用梯度下降法来求解最优解，我们计算代价函数的偏导数后得到梯度下降的更新公式为：</p><p><img src='media/bee72255d9d6fd5cec687dc35505d2dc.png' alt='' /></p><h3><a name='header-n931' class='md-header-anchor '></a>16.3 协同过滤</h3><p>参考视频: 16 - 3 - Collaborative Filtering (10 min).mkv</p><p>在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，使用这些特征训练出了每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征。</p><p><img src='media/9db087ad033c7cf41ace8863fa81135e.png' alt='' /></p><p>但是如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了。协同过滤算法可以同时学习这两者。</p><p>我们的优化目标便改为同时针对x和θ进行。</p><p><img src='media/39942875158360bfae4445f04e0ac0df.png' alt='' /></p><p>对代价函数求偏导数的结果如下：</p><p><img src='media/fed8cf2974c6c037050f3f50f9f33ffe.png' alt='' /></p><p>注：在协同过滤从算法中，我们通常不使用方差项，如果需要的话，算法会自动学得。
协同过滤算法使用步骤如下：</p><ol start='' ><li>初始 x(1),x(2),...,x(nm)，θ(1),θ(2),...,θ(nu)为一些随机小值</li><li>使用梯度下降算法最小化代价函数</li><li>在训练完算法后，我们预测(θ(j))Tx(i)为用户 j 给电影 i 的评分</li></ol><p>通过这个学习过程获得的特征矩阵包含了有关电影的重要数据，这些数据不总是人能读懂的，但是我们可以用这些数据作为给用户推荐电影的依据。</p><p>例如，如果一位用户正在观看电影 x(i)，我们可以寻找另一部电影
x(j)，依据两部电影的特征向量之间的距离||x(i)-x(j)||的大小。</p><h3><a name='header-n966' class='md-header-anchor '></a>16.4 协同过滤算法</h3><p>参考视频: 16 - 4 - Collaborative Filtering Algorithm (9 min).mkv</p><p>协同过滤优化目标：</p><p>给定</p><p><img src='media/9bccc06030f71e1250060dfa440ccd01.png' alt='' /></p><p>，估计</p><p><img src='media/34c5300125060a8bb3760a3bdb53f34c.png' alt='' /></p><p>：</p><p><img src='media/cc6b1c3d5674576b3088c62c4cfe946b.png' alt='' /></p><p>给定</p><p><img src='media/311cf2caf2bd235676f626c0e9c4e79c.png' alt='' /></p><p>，估计</p><p><img src='media/cf3b5bd59fad3471519ecb9cfa684fcb.png' alt='' /></p><p>：</p><p>同时最小化</p><p><img src='media/11df9c0e2035018bf19163a4d4689fb2.png' alt='' /></p><p>和</p><p><img src='media/7880005d0d3dc11791162f2dc6b90e82.png' alt='' /></p><p>：</p><p><img src='media/ca8dbf5ccb61cee5313c1d1e2e88bec1.png' alt='' /></p><p><img src='media/0a114336798efe7a88090a4bcec0c46b.png' alt='' /></p><p><img src='media/bf50429769ba4c38b31630cc6b827d3b.png' alt='' /></p><h3><a name='header-n1009' class='md-header-anchor '></a>16.5 向量化：低秩矩阵分解</h3><p>参考视频: 16 - 5 - Vectorization_ Low Rank Matrix Factorization (8 min).mkv</p><p>在上几节视频中，我们谈到了协同过滤算法，本节视频中我将会讲到有关该算法的向量化实现，以及说说有关该算法你可以做的其他事情。</p><p>举例子：</p><p>1.当给出一件产品时，你能否找到与之相关的其它产品。</p><p>2.一位用户最近看上一件产品，有没有其它相关的产品，你可以推荐给他。</p><p>我将要做的是：实现一种选择的方法，写出协同过滤算法的预测情况。</p><p>我们有关于五部电影的数据集，我将要做的是，将这些用户的电影评分，进行分组并存到一个矩阵中。</p><p>我们有五部电影，以及四位用户，那么 这个矩阵
Y就是一个5行4列的矩阵，它将这些电影的用户评分数据都存在矩阵里：</p><table><thead><tr><th><strong>Movie</strong></th><th><strong>Alice (1)</strong></th><th><strong>Bob (2)</strong></th><th><strong>Carol (3)</strong></th><th><strong>Dave (4)</strong></th></tr></thead><tbody><tr><td>Love at last</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>Romance forever</td><td>5</td><td>?</td><td>?</td><td>0</td></tr><tr><td>Cute puppies of love</td><td>?</td><td>4</td><td>0</td><td>?</td></tr><tr><td>Nonstop car chases</td><td>0</td><td>0</td><td>5</td><td>4</td></tr><tr><td>Swords vs. karate</td><td>0</td><td>0</td><td>5</td><td>?</td></tr></tbody></table><p><img src='media/42a92e07b32b593bb826f8f6bc4d9eb3.png' alt='' /></p><p>推出评分：</p><p><img src='media/c905a6f02e201a4767d869b3791e8aeb.png' alt='' /></p><p>找到相关影片：</p><p><img src='media/0a8b49da1ab852f2996a02afcaca2322.png' alt='' /></p><p>现在既然你已经对特征参数向量进行了学习，那么我们就会有一个很方便的方法来度量两部电影之间的相似性。例如说：电影i有一个特征向量x(i)，你是否能找到一部不同的电影
j，保证两部电影的特征向量之间的距离x(i)和x(j)很小，那就能很有力地表明电影 i
和电影 j 在某种程度上有相似，至少在某种意义上，某些人喜欢电影
i，或许更有可能也对电影 j 感兴趣。总结一下，当用户在看某部电影 i
的时候，如果你想找5部与电影非常相似的电影，为了能给用户推荐5部新电影，你需要做的是找出电影
j，在这些不同的电影中与我们要找的电影 i
的距离最小，这样你就能给你的用户推荐几部不同的电影了。</p><p>通过这个方法，希望你能知道，如何进行一个向量化的计算来对所有的用户和所有的电影进行评分计算。同时希望你也能掌握，通过学习特征参数，来找到相关电影和产品的方法。</p><h3><a name='header-n1084' class='md-header-anchor '></a>16.6 推行工作上的细节：均值归一化</h3><p>参考视频: 16 - 6 - Implementational Detail_ Mean Normalization (9 min).mkv</p><p>让我们来看下面的用户评分数据：</p><p><img src='media/54b1f7c3131aed24f9834d62a6835642.png' alt='' /></p><p>如果我们新增一个用户 Eve，并且 Eve 没有为任何电影评分，那么我们以什么为依据为
Eve推荐电影呢？</p><p>我们首先需要对结果 Y
矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有
用户对该电影评分的平均值：</p><p><img src='media/9ec5cb55e14bd1462183e104f8e02b80.png' alt='' /></p><p>然后我们利用这个新的 Y 矩阵来训练算法。
如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测(θ(j))T(x(i))+μi
对于Eve，我们的新模型会认为她给每部电影的评分都是该电影的平均分。</p></div>
</body>
</html>